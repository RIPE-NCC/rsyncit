stages:
  - build
  - package
  - deploy
  - security

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_PIPELINE_SOURCE == "external"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

include:
  - project: swe/gitlab-support
    file: /templates/security.yml
    inputs:
      stage: security
      needs: ["lockfile"]
  - project: swe/gitlab-support
    file: /templates/container.yml
    inputs:
      stage: security
      name: rsyncit
      image: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
      dockerfile: Dockerfile
      needs: ["docker-image"]
  - project: swe/gitlab-support
    file: /templates/approval.yml
    inputs:
      stage: .post
      access-token: "$APPROVAL_BOT_ACCESS_TOKEN"

# Disable the Gradle daemon for Continuous Integration servers as correctness
# is usually a priority over speed in CI environments. Using a fresh
# runtime for each build is more reliable since the runtime is completely
# isolated from any previous builds.
variables:
  DEBIAN_FRONTEND: noninteractive
  GRADLE_USER_HOME: "${CI_PROJECT_DIR}/.gradle/"
  GRADLE_OPTS: "-Dorg.gradle.caching=true -Dorg.gradle.parallel=true -Dorg.gradle.daemon=false"
  TERM: dumb

default:
  image: gradle:9.2-jdk21

# Cache per repository (not shared between forks?).
cache: &global_cache
  key: one-key-for-all
  # In general, only pull the cache. pull-push in the stage that gathers all
  # artifacts.
  policy: pull
  paths:
    - "${CI_PROJECT_DIR}/.gradle/caches"
    - "${CI_PROJECT_DIR}/.gradle/wrappers"

lockfile:
  stage: .pre
  cache:
    <<: *global_cache
    policy: pull-push
  script:
    - gradle dependencies --write-locks
  artifacts:
    paths:
      - "gradle.lockfile"

build:
  stage: build
  cache:
    <<: *global_cache
  script:
    - gradle build
    - cat ./build/reports/tests/test/index.html
  artifacts:
    paths:
      - build
    reports:
      junit:
        - build/test-results/test/*.xml
    expire_in: 4 weeks

# All the package stages only require the test job, so whitesource scanning can
# progress in parallel since this takes up to ten minutes.
docker-image:
  image: docker:29.1-cli
  services:
    - docker:29.1-dind
  stage: package
  needs: ["build"]
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - cp build/libs/rsyncit-*.jar rsyncit.jar
    - docker build --build-arg JAR_FILE=rsyncit.jar --label org.label-schema.vcs-ref="$CI_COMMIT_SHORT_SHA" --tag "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA" .
    - docker push "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"

release:latest:
  image: docker:29.1-cli
  services:
    - docker:29.1-dind
  stage: deploy
  needs: ["docker-image"]
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:latest
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - when: never

#
# Update a Salt-managed container with a new version of an image.
#
# Deploying a new image for a Salt-managed container requires retagging the new
# image with a fixed tag that matches the tag in pillar configuration
# (e.g. ':latest' or the name of the environment).
#
# Then Salt must apply the 'docker' target on the system with
# `update_containers` set. This will pull the new image, stop the old container
# and start a new one.
#
# The following variables are required as input for this job.
#
# - IMAGE: image to deploy
# - READINESS_URL: URL returning 200 Ok when the container is ready
# - SALT_API_PASSWORD: Password for Salt API
# - SALT_API_URL: URL of the API to control Salt master
# - SALT_API_USERNAME: Username for Salt API
# - TARGET_CONTAINER: name of the container to deploy
# - TARGET_HOST: host system that runs the container
# - TARGET_TAG: tag used on the target host
#
.salt-container-deploy: &salt-container-deploy
  image: docker-registry.ripe.net/swe/gitlab-ci/debian-deployenv
  stage: deploy
  script:
    - if [ -z "${TARGET_CONTAINER}" ]; then echo "set TARGET_CONTAINER"; exit 2; fi
    - if [ -z "${IMAGE}" ]; then echo "set IMAGE"; exit 2; fi
    - if [ -z "${READINESS_URL}" ]; then echo "set READINESS_URL"; exit 2; fi
    - if [ -z "${SALT_API_URL}" ]; then echo "set SALT_API_URL"; exit 2; fi
    - if [ -z "${TARGET_HOST}" ]; then echo "set TARGET_HOST"; exit 2; fi
    - if [ -z "${TARGET_TAG}" ]; then echo "set TARGET_TAG"; exit 2; fi

    - echo "Logging into ${CI_REGISTRY}"
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"

    - echo "Retagging '${IMAGE}' as '${IMAGE/:*/}:${TARGET_TAG}'"
    - docker pull "${IMAGE}"
    - docker tag "${IMAGE}" "${IMAGE/:*/}:${TARGET_TAG}"
    - docker push "${IMAGE/:*/}:${TARGET_TAG}"

    - echo "Logging into salt-api"
    - >
      curl -ik ${SALT_API_URL}/login \
        -c ./cookies.txt \
        -H 'Accept: application/x-yaml' \
        -d username="${SALT_API_USERNAME}" \
        -d password="${SALT_API_PASSWORD}" \
        -d eauth='ldap'

    - echo "Updating '${TARGET_CONTAINER}' container via salt on ${TARGET_HOST}"
    - >
      curl -D "/dev/stderr" -k "${SALT_API_URL}" \
        -b ./cookies.txt \
        -H 'Content-type: application/json' -d"
            [{
              \"timeout\": 120,
              \"failhard\": \"True\",
              \"client\": \"local_batch\",
              \"batch\": \"25%\",
              \"fun\": \"state.apply\",
              \"tgt_type\": \"glob\",
              \"tgt\": \"${TARGET_HOST}\",
              \"arg\": [\"docker\"],
              \"kwarg\": {
                \"pillar\": {
                  \"update_containers\": true
                }
              }
            }]
            " | jq -R '. as $raw | try fromjson catch $raw'

deploy:prepdev:
  <<: *salt-container-deploy
  needs: ["docker-image"]
  variables:
    IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    TARGET_CONTAINER: rsyncit
    READINESS_URL: http://127.0.0.1:8080/actuator/info
    TARGET_TAG: prepdev
  parallel:
    matrix:
      - TARGET_HOST: rsyncit-1.rpki.prepdev.ripe.net
        RSYNCIT_URL: http://rsyncit-1.rpki.prepdev.ripe.net:8080/actuator/info
      - TARGET_HOST: rsyncit-2.rpki.prepdev.ripe.net
        RSYNCIT_URL: http://rsyncit-2.rpki.prepdev.ripe.net:8080/actuator/info
  environment:
    name: prepdev
    url: "$RSYNCIT_URL"
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - when: manual

deploy:production:
  <<: *salt-container-deploy
  needs: ["docker-image"]
  variables:
    IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    TARGET_CONTAINER: rsyncit
    READINESS_URL: http://127.0.0.1:8080/actuator/info
    TARGET_TAG: production
  parallel:
    matrix:
      - TARGET_HOST: rsyncit-1.rpki.ripe.net
        RSYNCIT_URL: http://rsyncit-1.rpki.ripe.net:8080/actuator/info
      - TARGET_HOST: rsyncit-2.rpki.ripe.net
        RSYNCIT_URL: http://rsyncit-2.rpki.ripe.net:8080/actuator/info
  environment:
    name: production
    url: "$RSYNCIT_URL"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - when: never
